<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lifetime Variance Example</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@sunshowers6" />
        <meta name="twitter:creator" content="@sunshowers6" />
        <meta property="og:title" content="Lifetime Variance Example" />
        <meta property="og:url" content="https://lifetime-variance.sunshowers.io/print.md" />
        <meta property="og:description" content="Rust tutorial for lifetime variance, with code examples to show how covariance and contravariance works." />

        <meta name="description" content="Rust tutorial for lifetime variance, with code examples to show how covariance and contravariance works.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="additional/ferris.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lifetime Variance Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunshowers-code/lifetime-variance" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lifetime-variance-in-rust"><a class="header" href="#lifetime-variance-in-rust">Lifetime variance in Rust</a></h1>
<p>This document covers the basics of <em>variance</em> in Rust, as it applies to lifetimes, using code examples.</p>
<h2 id="locations"><a class="header" href="#locations">Locations</a></h2>
<p>This document is hosted online at <a href="https://lifetime-variance.sunshowers.io">https://lifetime-variance.sunshowers.io</a>. The source is hosted <a href="https://github.com/sunshowers-code/lifetime-variance">on GitHub</a>.</p>
<p>This document is available offline by installing <code>git</code> and running the following command while online.</p>
<pre><code>git clone https://github.com/sunshowers-code/lifetime-variance --branch gh-pages
</code></pre>
<p>then pointing your web browser at <code>lifetime-variance/index.html</code>.</p>
<p><a href="https://github.com/sunshowers-code/lifetime-variance/compare">Pull requests</a> to fix typos or unclear language are welcome!</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-intuition"><a class="header" href="#building-an-intuition">Building an intuition</a></h1>
<p>Consider this somewhat contrived function that takes a static string and makes
its lifetime shorter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn lifetime_shortener&lt;'a&gt;(s: &amp;'static str) -&gt; &amp;'a str {
    s
}</code></pre></pre>
<!-- Note: all the code sample names begin with "cell" rather than "hash-set" as you might expect. This is because hash sets should  -->
<p>Intuitively, this feels like it should compile: if a string lasts for the whole
process it should also last for any part of it. And it does!</p>
<p>Now let's make it a bit more complicated. Consider a mutable reference to a <code>HashSet</code>.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>fn hash_set_shortener&lt;'a, 'b&gt;(
    s: &amp;'a mut HashSet&lt;&amp;'static str&gt;,
) -&gt; &amp;'a mut HashSet&lt;&amp;'b str&gt; {
    s
}
</code></pre></pre>
<p><code>hash_set_shortener</code> doesn't compile!</p>
<p>Can you tell why? Think about it for a minute, try using your intuition...</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::iter::FromIterator;
</span><span class="boring">
</span>fn hash_set_example() {
    // Consider this HashSet over static strings.
    let mut my_set: HashSet&lt;&amp;'static str&gt; = HashSet::from_iter(["static"]);

    // Do you think this can work?
    let owned_string: String = "non_static".to_owned();
    my_set.insert(&amp;owned_string);

    // Doesn't seem like it can, right? my_set promises that the &amp;strs inside it
    // are all 'static, but we tried to put in an owned string scoped to this
    // function.
}</code></pre></pre>
<p>As a counterexample:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::{collections::HashSet, iter::FromIterator};
</span><span class="boring">
</span><span class="boring">fn hash_set_shortener&lt;'a, 'b&gt;(s: &amp;'a mut HashSet&lt;&amp;'static str&gt;) -&gt; &amp;'a mut HashSet&lt;&amp;'b str&gt; {
</span><span class="boring">    s
</span><span class="boring">}
</span><span class="boring">
</span>fn hash_set_counterexample() {
    let mut my_set: HashSet&lt;&amp;'static str&gt; = HashSet::from_iter(["static"]);
    let owned_string: String = "non_static".to_owned();

    // If we pretend that hash_set_shortener works...
    let shorter_set = hash_set_shortener(&amp;mut my_set);

    // then you could use `shorter_set` to insert a non-static string:
    shorter_set.insert(&amp;owned_string);

    // Now we can drop `shorter_set` to regain the ability to use `my_set`:
    std::mem::drop(shorter_set);

    // And my_set now has a non-static string in it. Whoops!
}</code></pre></pre>
<p>It isn't just <code>&amp;mut</code> which is problematic in this way. This also occurs with any sort of interior
mutability, like <code>RefCell</code>, <code>OnceCell</code>, or <code>Mutex</code> -- anything inside some sort of mutable context
has this issue.</p>
<p>Now, what about a hypothetical "lengthener" function?</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn lifetime_lengthener&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'static str {
    s
}
</code></pre></pre>
<p>This is clearly bogus, right? You can't just turn an arbitrary borrowed string
and make it last the duration of the entire process. Similarly:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>fn hash_set_lengthener&lt;'a, 'b&gt;(
    s: &amp;'a mut HashSet&lt;&amp;'b str&gt;,
) -&gt; &amp;'a mut HashSet&lt;&amp;'static str&gt; {
    s
}
</code></pre></pre>
<p>But what about this? fn is a pointer to a function that takes an arbitrary
borrowed string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn fn_ptr_lengthener&lt;'a&gt;(f: fn(&amp;'a str) -&gt; ()) -&gt; fn(&amp;'static str) -&gt; () {
    f
}</code></pre></pre>
<p>This feels like it should work. You can take a callback that takes an arbitrary borrowed string and
turn it into one that takes in a static string, since you're weakening the guarantee. And it does.</p>
<p>How can we handle these different cases in a principled way? That's where variance comes in. We're
going to talk about this in the next chapter, <em><a href="ch01-02-formalizing-variance.html">Formalizing variance</a></em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formalizing-variance"><a class="header" href="#formalizing-variance">Formalizing variance</a></h1>
<p>Some kinds of memory live longer than others.  This is captured through the idea
of the <em>outlives</em> relationship. If <code>'b</code> outlives <code>'a</code>, it is written as <code>'b: 'a</code>.
For example, in the definition:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() { }
</span><span class="boring">
</span>struct OutlivesExample&lt;'a, 'b: 'a&gt; {
    a_str: &amp;'a str,
    b_str: &amp;'b str,
}</code></pre>
<p>the borrowed string <code>b_str</code> lives at least as long as <code>a_str</code>, and possibly longer.</p>
<p> </p>
<p>The Rust compiler annotates every lifetime parameter with one of three settings.
For a type <code>T&lt;'a&gt;</code>, <code>'a</code> may be:</p>
<ul>
<li>
<p><strong>covariant</strong>, which means that if <code>'b: 'a</code> then <code>T&lt;'b&gt;: T&lt;'a&gt;</code>. This is the
default for immutable data.</p>
</li>
<li>
<p><strong>invariant</strong>, which means that even if <code>'b: 'a</code>, nothing can be said about
the relationship between <code>T&lt;'b&gt;</code> and <code>T&lt;'a&gt;</code>. This can happen for one of two reasons:</p>
<ul>
<li>
<p>If the lifetime is present "inside" some sort of mutable context -- whether
a <code>&amp;mut</code> reference, or interior mutability like <code>RefCell</code>, <code>OnceCell</code>, or<code>Mutex</code>.</p>
</li>
<li>
<p>If the lifetime is used in multiple spots where the variances conflict.
See <a href="./ch01-03-conflicts-and-type-parameters.html">Conflicts and type parameters</a> for
an example.</p>
</li>
</ul>
</li>
<li>
<p><strong>contravariant</strong>, which means that if <code>'b: 'a</code> then <code>T&lt;'a&gt;: T&lt;'b&gt;</code>. This is
uncommon and only shows up in parameters to <code>fn</code> pointers.</p>
</li>
</ul>
<p>The variance of a parameter is determined entirely through the type definition.
There's no marker trait for this.</p>
<h2 id="quick-exercise"><a class="header" href="#quick-exercise">Quick exercise</a></h2>
<p>In the struct below, what are the variances of each lifetime parameter?</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
    a: &amp;'a str,
    b: Cell&lt;&amp;'b str&gt;,
    c: fn(&amp;'c str) -&gt; usize,
    d: &amp;'d1 mut &amp;'d2 str,
}
<span class="boring">
</span><span class="boring">fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}</span></code></pre>
<h3 id="the-answers"><a class="header" href="#the-answers">The answers</a></h3>
<ul>
<li><code>'a</code> is <em>covariant</em>, because it only shows up in an immutable context.
This means that, similar to the shortener functions above, you can define a function like:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    a: &amp;'a str,
</span><span class="boring">    b: Cell&lt;&amp;'b str&gt;,
</span><span class="boring">    c: fn(&amp;'c str) -&gt; usize,
</span><span class="boring">    d: &amp;'d1 mut &amp;'d2 str,
</span><span class="boring">}
</span><span class="boring">
</span>fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
    x
}
<span class="boring">
</span><span class="boring">fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}</span></code></pre></pre>
<ul>
<li><code>'b</code> is <em>invariant</em>, because it is "inside" the mutable <code>Cell</code> context.</li>
</ul>
<blockquote>
<p><strong>Exercise</strong>: try writing a function that fails to compile because <code>'b</code> is <em>invariant</em>.</p>
</blockquote>
<ul>
<li><code>'c</code> is <em>contravariant</em>, because it shows up in the parameter to a callback.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    a: &amp;'a str,
</span><span class="boring">    b: Cell&lt;&amp;'b str&gt;,
</span><span class="boring">    c: fn(&amp;'c str) -&gt; usize,
</span><span class="boring">    d: &amp;'d1 mut &amp;'d2 str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span>fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
    x
}
<span class="boring">
</span><span class="boring">fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}</span></code></pre></pre>
<ul>
<li><code>'d1</code> is <em>covariant</em>! Even though it is a mutable reference, it is not "inside" the <code>&amp;mut</code> pointer.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    a: &amp;'a str,
</span><span class="boring">    b: Cell&lt;&amp;'b str&gt;,
</span><span class="boring">    c: fn(&amp;'c str) -&gt; usize,
</span><span class="boring">    d: &amp;'d1 mut &amp;'d2 str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span>fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
    x
}</code></pre></pre>
<ul>
<li><code>'d2</code> is <em>invariant</em>, because it is "inside" a <code>&amp;mut</code> reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conflicts-and-type-parameters"><a class="header" href="#conflicts-and-type-parameters">Conflicts and type parameters</a></h1>
<p>What if a lifetime parameter is used in multiple spots with different variances?
For example:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>struct TwoSpots&lt;'a&gt; {
    foo: &amp;'a str,
    bar: Cell&lt;&amp;'a str&gt;,
}</code></pre>
<p>It's as you might expect:</p>
<ul>
<li>If all the uses agree on a particular variance, the parameter has that variance.</li>
<li>Otherwise, the parameter defaults to <em>invariant</em>.</li>
</ul>
<p>And what about this sort of situation?</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>struct TypeParams&lt;T, U&gt; {
    t: Vec&lt;T&gt;,
    u: fn(U) -&gt; (),
}
<span class="boring">
</span><span class="boring">struct LifetimeParams&lt;'a, 'b&gt; {
</span><span class="boring">    nested: TypeParams&lt;&amp;'a str, &amp;'b str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn lifetime_check&lt;'a, 'b&gt;(
</span><span class="boring">    x: LifetimeParams&lt;'static, 'b&gt;
</span><span class="boring">) -&gt; LifetimeParams&lt;'a, 'static&gt; {
</span><span class="boring">    x
</span><span class="boring">}</span></code></pre>
<p><code>T</code> and <code>U</code> are also annotated with a variance, which is used if they're
substituted with a type containing a lifetime parameter. For example:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct TypeParams&lt;T, U&gt; {
</span><span class="boring">    t: Vec&lt;T&gt;,
</span><span class="boring">    u: fn(U) -&gt; (),
</span><span class="boring">}
</span><span class="boring">
</span>struct LifetimeParams&lt;'a, 'b&gt; {
    nested: TypeParams&lt;&amp;'a str, &amp;'b str&gt;,
}
<span class="boring">
</span><span class="boring">fn lifetime_check&lt;'a, 'b&gt;(
</span><span class="boring">    x: LifetimeParams&lt;'static, 'b&gt;
</span><span class="boring">) -&gt; LifetimeParams&lt;'a, 'static&gt; {
</span><span class="boring">    x
</span><span class="boring">}</span></code></pre>
<p>Here, <code>'a</code> is <em>covariant</em> and <code>'b</code> is <em>contravariant</em>. Let's test those together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct TypeParams&lt;T, U&gt; {
</span><span class="boring">    t: Vec&lt;T&gt;,
</span><span class="boring">    u: fn(U) -&gt; (),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LifetimeParams&lt;'a, 'b&gt; {
</span><span class="boring">    nested: TypeParams&lt;&amp;'a str, &amp;'b str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn lifetime_check&lt;'a, 'b&gt;(
    x: LifetimeParams&lt;'static, 'b&gt;
) -&gt; LifetimeParams&lt;'a, 'static&gt; {
    x
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variance-in-practice"><a class="header" href="#variance-in-practice">Variance in practice</a></h1>
<p>So why should you, as a Rust developer, care?</p>
<p>Many Rust developers start off by using reference counted smart pointers like
<code>Rc</code> or <code>Arc</code> instead of borrowed data everywhere. If you're doing that, you're
unlikely to run into lifetime issues. But you may eventually want to switch to
borrowed data to get maximum performance -- if so, you'll probably have to introduce
lifetime parameters into your code. That's when variance becomes important. Some
of the thorniest issues getting rustc to accept code with pervasive use of borrowed
data end up boiling down to variance in some fashion.</p>
<p>For example, consider this situation, extracted from some real-world Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span>// Consider this struct representing a message.
struct Message&lt;'msg&gt; {
    message: &amp;'msg str,
}

// ... this struct that collects messages to be displayed.
struct MessageCollector&lt;'a, 'msg&gt; {
    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
}

impl&lt;'a, 'msg&gt; MessageCollector&lt;'a, 'msg&gt; {
    // This adds a message to the end of the list.
    fn add_message(&amp;mut self, message: Message&lt;'msg&gt;) {
        self.list.push(message);
    }
}

// And this struct that displays collected messages.
struct MessageDisplayer&lt;'a, 'msg&gt; {
    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
}

impl&lt;'a, 'msg&gt; fmt::Display for MessageDisplayer&lt;'a, 'msg&gt; {
    // This displays all the messages, separated by newlines.
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        for message in self.list {
            write!(f, "{}\n", message.message)?;
        }
        Ok(())
    }
}

fn message_example() {
    // Here's a simple pool of messages.
    let mut message_pool: HashSet&lt;String&gt; = HashSet::new();
    message_pool.insert("ten".to_owned());
    message_pool.insert("twenty".to_owned());

    // All right, let's try collecting and displaying some messages!
    collect_and_display(&amp;message_pool);
}

fn collect_and_display&lt;'msg&gt;(message_pool: &amp;'msg HashSet&lt;String&gt;) {
    let mut list = vec![];

    // Collect some messages. (This is pretty simple but you can imagine the
    // collector being passed into other code.)
    let mut collector = MessageCollector { list: &amp;mut list };
    for message in message_pool {
        collector.add_message(Message { message });
    }

    // Now let's display those messages!
    let displayer = MessageDisplayer { list: &amp;list };
    println!("{}", displayer);
}</code></pre></pre>
<p>This works, but can it be simplified?</p>
<p>Let's try reducing the number of lifetime parameters, first for the displayer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'msg&gt; MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    fn add_message(&amp;mut self, message: Message&lt;'msg&gt;) {
</span><span class="boring">        self.list.push(message);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageDisplayer&lt;'a&gt; {
    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; fmt::Display for SimpleMessageDisplayer&lt;'a&gt; {
    // This displays all the messages.
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        for message in self.list {
            write!(f, "{}\n", message.message)?;
        }
        Ok(())
    }
}

fn collect_and_display_2&lt;'msg&gt;(message_pool: &amp;'msg HashSet&lt;String&gt;) {
    // OK, let's do the same thing as collect_and_display, except using the
    // simple displayer.
    let mut list = vec![];

    // Collect some messages.
    let mut collector = MessageCollector { list: &amp;mut list };
    for message in message_pool {
        collector.add_message(Message { message });
    }

    // Finally, display them.
    let displayer = SimpleMessageDisplayer { list: &amp;list };
    println!("{}", displayer);
}</code></pre></pre>
<p>OK, that worked. Can we do the same for the collector? Let's try it out:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'msg&gt; MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    fn add_message(&amp;mut self, message: Message&lt;'msg&gt;) {
</span><span class="boring">        self.list.push(message);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; fmt::Display for SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        for message in self.list {
</span><span class="boring">            write!(f, "{}\n", message.message)?;
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageCollector&lt;'a&gt; {
    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; SimpleMessageCollector&lt;'a&gt; {
    // This adds a message to the end of the list.
    fn add_message(&amp;mut self, message: Message&lt;'a&gt;) {
        self.list.push(message);
    }
}

fn collect_and_display_3&lt;'msg&gt;(message_pool: &amp;'msg HashSet&lt;String&gt;) {
    // OK, one more time.
    let mut list = vec![];

    // Collect some messages.
    let mut collector = SimpleMessageCollector { list: &amp;mut list };
    for message in message_pool {
        collector.add_message(Message { message });
    }

    // Finally, display them.
    let displayer = SimpleMessageDisplayer { list: &amp;list };
    println!("{}", displayer);
}</code></pre></pre>
<p>That doesn't work! rustc (as of 1.43.1) errors out with <code>cannot borrow `list` as immutable because it is also borrowed as mutable</code>.</p>
<p>Why did reducing the number of lifetime params work for <code>MessageDisplayer</code> but not
<code>MessageCollector</code>? It's all because of variance. Let's have a look at the structs
again, first the displayer:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span>struct MessageDisplayer&lt;'a, 'msg&gt; {
    // Two lifetime parameters:
    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
    // Here, the compiler can vary the two independently, so the list can be
    // held onto a shorter lifetime than 'msg, then released.
}
<span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots:
</span><span class="boring">    //
</span><span class="boring">    //     |               |
</span><span class="boring">    //     v               v
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // But since both of them are covariant (in immutable positions), 'a is
</span><span class="boring">    // covariant as well.  This means that the compiler can internally transform
</span><span class="boring">    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
</span><span class="boring">    // list for the shorter 'a duration.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters, again:
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, 'a is covariant, but 'msg is invariant since it is "inside"
</span><span class="boring">    // a &amp;mut reference. The compiler can vary the two independently, which
</span><span class="boring">    // means that the list can be held onto for a shorter lifetime than 'msg.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageCollector&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots again:
</span><span class="boring">    //
</span><span class="boring">    //     |                   |
</span><span class="boring">    //     v                   v
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // The first 'a is covariant, but the second one is invariant since it is
</span><span class="boring">    // "inside" a &amp;mut reference! This means that 'a is invariant, and this
</span><span class="boring">    // ends up causing the compiler to try and hold on to the list for longer
</span><span class="boring">    // than with the standard MessageCollector.
</span><span class="boring">}</span></code></pre>
<p>The simple version:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageDisplayer&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters:
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, the compiler can vary the two independently, so the list can be
</span><span class="boring">    // held onto a shorter lifetime than 'msg, then released.
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageDisplayer&lt;'a&gt; {
    // 'a is used in two spots:
    //
    //     |               |
    //     v               v
    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
    //
    // But since both of them are covariant (in immutable positions), 'a is
    // covariant as well.  This means that the compiler can internally transform
    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
    // list for the shorter 'a duration.
}
<span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters, again:
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, 'a is covariant, but 'msg is invariant since it is "inside"
</span><span class="boring">    // a &amp;mut reference. The compiler can vary the two independently, which
</span><span class="boring">    // means that the list can be held onto for a shorter lifetime than 'msg.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageCollector&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots again:
</span><span class="boring">    //
</span><span class="boring">    //     |                   |
</span><span class="boring">    //     v                   v
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // The first 'a is covariant, but the second one is invariant since it is
</span><span class="boring">    // "inside" a &amp;mut reference! This means that 'a is invariant, and this
</span><span class="boring">    // ends up causing the compiler to try and hold on to the list for longer
</span><span class="boring">    // than with the standard MessageCollector.
</span><span class="boring">}</span></code></pre>
<p>Now the collector:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageDisplayer&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters:
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, the compiler can vary the two independently, so the list can be
</span><span class="boring">    // held onto a shorter lifetime than 'msg, then released.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots:
</span><span class="boring">    //
</span><span class="boring">    //     |               |
</span><span class="boring">    //     v               v
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // But since both of them are covariant (in immutable positions), 'a is
</span><span class="boring">    // covariant as well.  This means that the compiler can internally transform
</span><span class="boring">    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
</span><span class="boring">    // list for the shorter 'a duration.
</span><span class="boring">}
</span><span class="boring">
</span>struct MessageCollector&lt;'a, 'msg&gt; {
    // Two lifetime parameters, again:
    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
    // Here, 'a is covariant, but 'msg is invariant since it is "inside"
    // a &amp;mut reference. The compiler can vary the two independently, which
    // means that the list can be held onto for a shorter lifetime than 'msg.
}
<span class="boring">
</span><span class="boring">struct SimpleMessageCollector&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots again:
</span><span class="boring">    //
</span><span class="boring">    //     |                   |
</span><span class="boring">    //     v                   v
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // The first 'a is covariant, but the second one is invariant since it is
</span><span class="boring">    // "inside" a &amp;mut reference! This means that 'a is invariant, and this
</span><span class="boring">    // ends up causing the compiler to try and hold on to the list for longer
</span><span class="boring">    // than with the standard MessageCollector.
</span><span class="boring">}</span></code></pre>
<p>Finally, the problematic simple version:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageDisplayer&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters:
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, the compiler can vary the two independently, so the list can be
</span><span class="boring">    // held onto a shorter lifetime than 'msg, then released.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots:
</span><span class="boring">    //
</span><span class="boring">    //     |               |
</span><span class="boring">    //     v               v
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // But since both of them are covariant (in immutable positions), 'a is
</span><span class="boring">    // covariant as well.  This means that the compiler can internally transform
</span><span class="boring">    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
</span><span class="boring">    // list for the shorter 'a duration.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters, again:
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, 'a is covariant, but 'msg is invariant since it is "inside"
</span><span class="boring">    // a &amp;mut reference. The compiler can vary the two independently, which
</span><span class="boring">    // means that the list can be held onto for a shorter lifetime than 'msg.
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageCollector&lt;'a&gt; {
    // 'a is used in two spots again:
    //
    //     |                   |
    //     v                   v
    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
    //
    // The first 'a is covariant, but the second one is invariant since it is
    // "inside" a &amp;mut reference! This means that 'a is invariant, and this
    // ends up causing the compiler to try and hold on to the list for longer
    // than with the standard MessageCollector.
}</code></pre>
<h3 id="a-final-note-if-youre-writing-a-rust-library"><a class="header" href="#a-final-note-if-youre-writing-a-rust-library">A final note if you're writing a Rust library</a></h3>
<p>Changing the variance of a parameter (lifetime or type) from <em>covariant</em> to
anything else, or from <em>contravariant</em> to anything else, is a BREAKING CHANGE.
If you're following semver, it can only be done with a new major version.</p>
<p>Changing a parameter from <em>invariant</em> to <em>co-</em> or <em>contravariant</em> is not a breaking change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h1>
<p>Hope this made you feel more confident using lifetimes in your Rust code!
They're a very powerful way to write safe, blazing fast code. But variance can
often cause obscure issues in practice -- knowledge of how it works is key to
using lifetimes effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<p>Thanks to the following people for their feedback:</p>
<ul>
<li>Nikolai Vazquez (<a href="https://twitter.com/NikolaiVazquez">Twitter</a>, <a href="https://github.com/nvzqz">GitHub</a>)</li>
<li>Inanna Malick (<a href="https://twitter.com/inanna_malick">Twitter</a>, <a href="https://github.com/inanna-malick">GitHub</a>)</li>
</ul>
<p>And thanks to Berkay Dinç (<a href="https://github.com/brkydnc">GitHub</a>) for converting the tutorial over to mdbook.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="additional/ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
