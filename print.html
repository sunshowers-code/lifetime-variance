<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lifetime Variance Example</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@sunshowers6" />
<meta name="twitter:creator" content="@sunshowers6" />
<meta property="og:title" content="Lifetime Variance Example" />
<meta property="og:url" content="https://lifetime-variance.sunshowers.io/print.md" />
<meta property="og:description" content="Rust tutorial for lifetime variance, with code examples to show how covariance and contravariance works." />

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust tutorial for lifetime variance, with code examples to show how covariance and contravariance works.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="additional/ferris.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Lifetime variance in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-building-an-intuition.html"><strong aria-hidden="true">1.1.</strong> Building an intuition</a></li><li class="chapter-item expanded "><a href="ch01-02-formalizing-variance.html"><strong aria-hidden="true">1.2.</strong> Formalizing variance</a></li><li class="chapter-item expanded "><a href="ch01-03-conflicts-and-type-parameters.html"><strong aria-hidden="true">1.3.</strong> Conflicts and type parameters</a></li><li class="chapter-item expanded "><a href="ch01-04-variance-in-practice.html"><strong aria-hidden="true">1.4.</strong> Variance in practice</a></li><li class="chapter-item expanded "><a href="ch01-05-epilogue.html"><strong aria-hidden="true">1.5.</strong> Epilogue</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-acknowledgements.html"><strong aria-hidden="true">2.</strong> Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lifetime Variance Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunshowers-code/lifetime-variance" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lifetime-variance-in-rust"><a class="header" href="#lifetime-variance-in-rust">Lifetime variance in Rust</a></h1>
<p>This document covers the basics of <em>variance</em> in Rust, as it applies to lifetimes, using code examples.</p>
<h2 id="locations"><a class="header" href="#locations">Locations</a></h2>
<p>This document is hosted online at <a href="https://lifetime-variance.sunshowers.io">https://lifetime-variance.sunshowers.io</a>. The source is hosted <a href="https://github.com/sunshowers/lifetime-variance">on GitHub</a>.</p>
<p>This document is available offline by installing <code>git</code> and running the following command while online.</p>
<pre><code>git clone https://github.com/sunshowers-code/lifetime-variance --branch gh-pages
</code></pre>
<p>then pointing your web browser at <code>lifetime-variance/index.html</code>.</p>
<p><a href="https://github.com/sunshowers-code/lifetime-variance/compare">Pull requests</a> to fix typos or unclear language are welcome!</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-intuition"><a class="header" href="#building-an-intuition">Building an intuition</a></h1>
<p>Consider this somewhat contrived function that takes a static string and makes
its lifetime shorter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn lifetime_shortener&lt;'a&gt;(s: &amp;'static str) -&gt; &amp;'a str {
    s
}
</code></pre></pre>
<p>Intuitively, this feels like it should compile: if a string lasts for the whole
process it should also last for any part of it. And it does!</p>
<p>Now let's make it slightly more complicated. Let's introduce a <code>Cell</code> into the
picture. As a reminder, a <code>Cell</code> allows for the data inside it to be changed.</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>fn cell_shortener&lt;'a, 'b&gt;(s: &amp;'a Cell&lt;&amp;'static str&gt;) -&gt; &amp;'a Cell&lt;&amp;'b str&gt; {
    s
}

</code></pre></pre>
<p><code>cell_shortener</code> doesn't compile :( Can you tell why? Think about it for a minute,
try using your intuition...</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>fn cell_example() {
    // Consider this Cell. It holds a static string.
    let foo: Cell&lt;&amp;'static str&gt; = Cell::new(&quot;foo&quot;);

    // Do you think this can work?
    let owned_string: String = &quot;non_static&quot;.to_owned();
    foo.replace(&amp;owned_string);

    // Doesn't seem like it can, right? foo promises that what's inside it is
    // a &amp;'static str, but we tried to put in an owned string scoped to this
    // function.
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">fn cell_shortener&lt;'a, 'b&gt;(s: &amp;'a Cell&lt;&amp;'static str&gt;) -&gt; &amp;'a Cell&lt;&amp;'b str&gt; {
</span><span class="boring">    s
</span><span class="boring">}
</span><span class="boring">
</span>fn cell_counterexample() {
    let foo: Cell&lt;&amp;'static str&gt; = Cell::new(&quot;foo&quot;);
    let owned_string: String = &quot;non_static&quot;.to_owned();
  
    // If we pretend that cell_shortener works
    let shorter_foo = cell_shortener(&amp;foo);
  
    // then `shorter_foo` and `foo` would be aliases of each other, which would
    // mean that you could use `shorter_foo` to replace `foo`s `Cell` with a
    // non-static string:
    shorter_foo.replace(&amp;owned_string);
  
    // Now `foo`, which is an alias of `shorter_foo`, has a non-static string
    // in it! Whoops.
}
</code></pre></pre>
<p>It isn't just <code>Cell</code> which is problematic in this way. <code>RefCell</code>, <code>OnceCell</code>,
<code>Mutex</code>, <code>&amp;mut</code> references -- anything &quot;inside&quot; some sort of mutable context has
this issue.</p>
<p>Now, what about a hypothetical &quot;lengthener&quot; function?</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn lifetime_lengthener&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'static str {
    s
}

</code></pre></pre>
<p>This is obviously bogus, right? You can't just turn an arbitrary borrowed string
and make it last the duration of the entire process. Similarly:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>fn cell_lengthener&lt;'a, 'b&gt;(s: &amp;'a Cell&lt;&amp;'b str&gt;) -&gt; &amp;'a Cell&lt;&amp;'static str&gt; {
    s
}

</code></pre></pre>
<p>But what about this? fn is a pointer to a function that takes an arbitrary
borrowed string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>fn fn_ptr_lengthener&lt;'a&gt;(f: fn(&amp;'a str) -&gt; ()) -&gt; fn(&amp;'static str) -&gt; () {
    f
}
</code></pre></pre>
<p>Ahhh, intuitively, this should work. And it does. You can take a callback that
takes an arbitrary borrowed string and turn it into one that takes in a static string.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formalizing-variance"><a class="header" href="#formalizing-variance">Formalizing variance</a></h1>
<p>How can all these intuitions be formalized? It's done through the idea of <em>variance</em>.</p>
<p>Some kinds of memory live longer than others.  This is captured through the idea
of the <em>outlives</em> relationship. If <code>'b</code> outlives <code>'a</code>, it is written as <code>'b: 'a</code>.
For example, in the definition:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() { }
</span><span class="boring">
</span>struct OutlivesExample&lt;'a, 'b: 'a&gt; {
    a_str: &amp;'a str,
    b_str: &amp;'b str,
}
</code></pre>
<p>the borrowed string <code>b_str</code> lives at least as long as <code>a_str</code>, and possibly longer.</p>
<p> </p>
<p>The Rust compiler annotates every lifetime parameter with one of three settings.
For a type <code>T&lt;'a&gt;</code>, <code>'a</code> may be:</p>
<ul>
<li>
<p><strong>covariant</strong>, which means that if <code>'b: 'a</code> then <code>T&lt;'b&gt;: T&lt;'a&gt;</code>. This is the
default for immutable data.</p>
</li>
<li>
<p><strong>invariant</strong>, which means that even if <code>'b: 'a</code>, nothing can be said about
the relationship between <code>T&lt;'b&gt;</code> and <code>T&lt;'a&gt;</code>. This can happen for one of two reasons:</p>
<ul>
<li>
<p>If the lifetime is present &quot;inside&quot; some sort of mutable context -- whether
a <code>&amp;mut</code> reference, or interior mutability like <code>Cell</code>/<code>RefCell</code>/<code>Mutex</code>.</p>
</li>
<li>
<p>If the lifetime is used in multiple spots where the variances conflict.
See <a href="./ch01-03-conflicts-and-type-parameters.html">Conflicts and type parameters</a> for
an example.</p>
</li>
</ul>
</li>
<li>
<p><strong>contravariant</strong>, which means that if <code>'b: 'a</code> then <code>T&lt;'a&gt;: T&lt;'b&gt;</code>. This is
uncommon and only shows up in parameters to <code>fn</code> pointers.</p>
</li>
</ul>
<p>The variance of a parameter is determined entirely through the type definition.
There's no marker trait for this.</p>
<h2 id="quick-exercise"><a class="header" href="#quick-exercise">Quick exercise</a></h2>
<p>In the struct below, what are the variances of each lifetime parameter?</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
    a: &amp;'a str,
    b: Cell&lt;&amp;'b str&gt;,
    c: fn(&amp;'c str) -&gt; usize,
    d: &amp;'d1 mut &amp;'d2 str,
}
<span class="boring">
</span><span class="boring">fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span></code></pre>
<h3 id="the-answers"><a class="header" href="#the-answers">The answers</a></h3>
<ul>
<li><code>'a</code> is <em>covariant</em>, because it only shows up in an immutable context.
This means that, similar to the shortener functions above, you can define a function like:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    a: &amp;'a str,
</span><span class="boring">    b: Cell&lt;&amp;'b str&gt;,
</span><span class="boring">    c: fn(&amp;'c str) -&gt; usize,
</span><span class="boring">    d: &amp;'d1 mut &amp;'d2 str,
</span><span class="boring">}
</span><span class="boring">
</span>fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
    x
}
<span class="boring">
</span><span class="boring">fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>'b</code> is <em>invariant</em>, because it is &quot;inside&quot; the mutable <code>Cell</code> context.</li>
</ul>
<blockquote>
<p><strong>Exercise</strong>: try writing a function that fails to compile because <code>'b</code> is <em>invariant</em>.</p>
</blockquote>
<ul>
<li><code>'c</code> is <em>contravariant</em>, because it shows up in the parameter to a callback.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    a: &amp;'a str,
</span><span class="boring">    b: Cell&lt;&amp;'b str&gt;,
</span><span class="boring">    c: fn(&amp;'c str) -&gt; usize,
</span><span class="boring">    d: &amp;'d1 mut &amp;'d2 str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span>fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
    x
}
<span class="boring">
</span><span class="boring">fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>'d1</code> is <em>covariant</em>! Even though it is a mutable reference, it is not &quot;inside&quot; the <code>&amp;mut</code> pointer.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span><span class="boring">struct Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    a: &amp;'a str,
</span><span class="boring">    b: Cell&lt;&amp;'b str&gt;,
</span><span class="boring">    c: fn(&amp;'c str) -&gt; usize,
</span><span class="boring">    d: &amp;'d1 mut &amp;'d2 str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn a&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'static, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn c&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
</span><span class="boring">    x: Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt;
</span><span class="boring">) -&gt; Multi&lt;'a, 'b, 'static, 'd1, 'd2&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span><span class="boring">
</span>fn d1&lt;'a, 'b, 'c, 'd1, 'd2&gt;(
    x: Multi&lt;'a, 'b, 'c, 'static, 'd2&gt;
) -&gt; Multi&lt;'a, 'b, 'c, 'd1, 'd2&gt; {
    x
}
</code></pre></pre>
<ul>
<li><code>'d2</code> is <em>invariant</em>, because it is &quot;inside&quot; a <code>&amp;mut</code> reference.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conflicts-and-type-parameters"><a class="header" href="#conflicts-and-type-parameters">Conflicts and type parameters</a></h1>
<p>What if a lifetime parameter is used in multiple spots with different variances?
For example:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::cell::Cell;
</span><span class="boring">
</span>struct TwoSpots&lt;'a&gt; {
    foo: &amp;'a str,
    bar: Cell&lt;&amp;'a str&gt;,
}
</code></pre>
<p>It's as you might expect:</p>
<ul>
<li>If all the uses agree on a particular variance, the parameter has that variance.</li>
<li>Otherwise, the parameter defaults to <em>invariant</em>.</li>
</ul>
<p>And what about this sort of situation?</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>struct TypeParams&lt;T, U&gt; {
    t: Vec&lt;T&gt;,
    u: fn(U) -&gt; (),
}
<span class="boring">
</span><span class="boring">struct LifetimeParams&lt;'a, 'b&gt; {
</span><span class="boring">    nested: TypeParams&lt;&amp;'a str, &amp;'b str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn lifetime_check&lt;'a, 'b&gt;(
</span><span class="boring">    x: LifetimeParams&lt;'static, 'b&gt;
</span><span class="boring">) -&gt; LifetimeParams&lt;'a, 'static&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span></code></pre>
<p><code>T</code> and <code>U</code> are also annotated with a variance, which is used if they're
substituted with a type containing a lifetime parameter. For example:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct TypeParams&lt;T, U&gt; {
</span><span class="boring">    t: Vec&lt;T&gt;,
</span><span class="boring">    u: fn(U) -&gt; (),
</span><span class="boring">}
</span><span class="boring">
</span>struct LifetimeParams&lt;'a, 'b&gt; {
    nested: TypeParams&lt;&amp;'a str, &amp;'b str&gt;,
}
<span class="boring">
</span><span class="boring">fn lifetime_check&lt;'a, 'b&gt;(
</span><span class="boring">    x: LifetimeParams&lt;'static, 'b&gt;
</span><span class="boring">) -&gt; LifetimeParams&lt;'a, 'static&gt; {
</span><span class="boring">    x
</span><span class="boring">}
</span></code></pre>
<p>Here, <code>'a</code> is <em>covariant</em> and <code>'b</code> is <em>contravariant</em>. Let's test those together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct TypeParams&lt;T, U&gt; {
</span><span class="boring">    t: Vec&lt;T&gt;,
</span><span class="boring">    u: fn(U) -&gt; (),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct LifetimeParams&lt;'a, 'b&gt; {
</span><span class="boring">    nested: TypeParams&lt;&amp;'a str, &amp;'b str&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn lifetime_check&lt;'a, 'b&gt;(
    x: LifetimeParams&lt;'static, 'b&gt;
) -&gt; LifetimeParams&lt;'a, 'static&gt; {
    x
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variance-in-practice"><a class="header" href="#variance-in-practice">Variance in practice</a></h1>
<p>So why should you, as a Rust developer, care?</p>
<p>Many Rust developers start off by using reference counted smart pointers like
<code>Rc</code> or <code>Arc</code> instead of borrowed data everywhere. If you're doing that, you're
unlikely to run into lifetime issues. But you may eventually want to switch to
borrowed data to get maximum performance -- if so, you'll probably have to introduce
lifetime parameters into your code. That's when variance becomes important. Some
of the thorniest issues getting rustc to accept code with pervasive use of borrowed
data end up boiling down to variance in some fashion.</p>
<p>For example, consider this situation, extracted from some real-world Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span>// Consider this struct representing a message.
struct Message&lt;'msg&gt; {
    message: &amp;'msg str,
}

// ... this struct that collects messages to be displayed.
struct MessageCollector&lt;'a, 'msg&gt; {
    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
}

impl&lt;'a, 'msg&gt; MessageCollector&lt;'a, 'msg&gt; {
    // This adds a message to the end of the list.
    fn add_message(&amp;mut self, message: Message&lt;'msg&gt;) {
        self.list.push(message);
    }
}

// And this struct that displays collected messages.
struct MessageDisplayer&lt;'a, 'msg&gt; {
    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
}

impl&lt;'a, 'msg&gt; fmt::Display for MessageDisplayer&lt;'a, 'msg&gt; {
    // This displays all the messages, separated by newlines.
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        for message in self.list {
            write!(f, &quot;{}\n&quot;, message.message)?;
        }
        Ok(())
    }
}

fn message_example() {
    // Here's a simple pool of messages.
    let mut message_pool: HashSet&lt;String&gt; = HashSet::new();
    message_pool.insert(&quot;ten&quot;.to_owned());
    message_pool.insert(&quot;twenty&quot;.to_owned());

    // All right, let's try collecting and displaying some messages!
    collect_and_display(&amp;message_pool);
}

fn collect_and_display&lt;'msg&gt;(message_pool: &amp;'msg HashSet&lt;String&gt;) {
    let mut list = vec![];

    // Collect some messages. (This is pretty simple but you can imagine the
    // collector being passed into other code.)
    let mut collector = MessageCollector { list: &amp;mut list };
    for message in message_pool {
        collector.add_message(Message { message });
    }

    // Now let's display those messages!
    let displayer = MessageDisplayer { list: &amp;list };
    println!(&quot;{}&quot;, displayer);
}
</code></pre></pre>
<p>This works, but can it be simplified?</p>
<p>Let's try reducing the number of lifetime parameters, first for the displayer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'msg&gt; MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    fn add_message(&amp;mut self, message: Message&lt;'msg&gt;) {
</span><span class="boring">        self.list.push(message);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageDisplayer&lt;'a&gt; {
    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; fmt::Display for SimpleMessageDisplayer&lt;'a&gt; {
    // This displays all the messages.
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        for message in self.list {
            write!(f, &quot;{}\n&quot;, message.message)?;
        }
        Ok(())
    }
}

fn collect_and_display_2&lt;'msg&gt;(message_pool: &amp;'msg HashSet&lt;String&gt;) {
    // OK, let's do the same thing as collect_and_display, except using the
    // simple displayer.
    let mut list = vec![];

    // Collect some messages.
    let mut collector = MessageCollector { list: &amp;mut list };
    for message in message_pool {
        collector.add_message(Message { message });
    }

    // Finally, display them.
    let displayer = SimpleMessageDisplayer { list: &amp;list };
    println!(&quot;{}&quot;, displayer);
}
</code></pre></pre>
<p>OK, that worked. Can we do the same for the collector? Let's try it out:</p>
<pre><pre class="playground"><code class="language-rust does_not_compile"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'msg&gt; MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    fn add_message(&amp;mut self, message: Message&lt;'msg&gt;) {
</span><span class="boring">        self.list.push(message);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; fmt::Display for SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        for message in self.list {
</span><span class="boring">            write!(f, &quot;{}\n&quot;, message.message)?;
</span><span class="boring">        }
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageCollector&lt;'a&gt; {
    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; SimpleMessageCollector&lt;'a&gt; {
    // This adds a message to the end of the list.
    fn add_message(&amp;mut self, message: Message&lt;'a&gt;) {
        self.list.push(message);
    }
}

fn collect_and_display_3&lt;'msg&gt;(message_pool: &amp;'msg HashSet&lt;String&gt;) {
    // OK, one more time.
    let mut list = vec![];

    // Collect some messages.
    let mut collector = SimpleMessageCollector { list: &amp;mut list };
    for message in message_pool {
        collector.add_message(Message { message });
    }

    // Finally, display them.
    let displayer = SimpleMessageDisplayer { list: &amp;list };
    println!(&quot;{}&quot;, displayer);
}
</code></pre></pre>
<p>That doesn't work! rustc (as of 1.43.1) errors out with <code>cannot borrow `list` as immutable because it is also borrowed as mutable</code>.</p>
<p>Why did reducing the number of lifetime params work for <code>MessageDisplayer</code> but not
<code>MessageCollector</code>? It's all because of variance. Let's have a look at the structs
again, first the displayer:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span>struct MessageDisplayer&lt;'a, 'msg&gt; {
    // Two lifetime parameters:
    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
    // Here, the compiler can vary the two independently, so the list can be
    // held onto a shorter lifetime than 'msg, then released.
}
<span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots:
</span><span class="boring">    //
</span><span class="boring">    //     |               |
</span><span class="boring">    //     v               v
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // But since both of them are covariant (in immutable positions), 'a is
</span><span class="boring">    // covariant as well.  This means that the compiler can internally transform
</span><span class="boring">    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
</span><span class="boring">    // list for the shorter 'a duration.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters, again:
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, 'a is covariant, but 'msg is invariant since it is &quot;inside&quot;
</span><span class="boring">    // a &amp;mut reference. The compiler can vary the two independently, which
</span><span class="boring">    // means that the list can be held onto for a shorter lifetime than 'msg.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageCollector&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots again:
</span><span class="boring">    //
</span><span class="boring">    //     |                   |
</span><span class="boring">    //     v                   v
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // The first 'a is covariant, but the second one is invariant since it is
</span><span class="boring">    // &quot;inside&quot; a &amp;mut reference! This means that 'a is invariant, and this
</span><span class="boring">    // ends up causing the compiler to try and hold on to the list for longer
</span><span class="boring">    // than with the standard MessageCollector.
</span><span class="boring">}
</span></code></pre>
<p>The simple version:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageDisplayer&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters:
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, the compiler can vary the two independently, so the list can be
</span><span class="boring">    // held onto a shorter lifetime than 'msg, then released.
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageDisplayer&lt;'a&gt; {
    // 'a is used in two spots:
    //
    //     |               |
    //     v               v
    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
    //
    // But since both of them are covariant (in immutable positions), 'a is
    // covariant as well.  This means that the compiler can internally transform
    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
    // list for the shorter 'a duration.
}
<span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters, again:
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, 'a is covariant, but 'msg is invariant since it is &quot;inside&quot;
</span><span class="boring">    // a &amp;mut reference. The compiler can vary the two independently, which
</span><span class="boring">    // means that the list can be held onto for a shorter lifetime than 'msg.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageCollector&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots again:
</span><span class="boring">    //
</span><span class="boring">    //     |                   |
</span><span class="boring">    //     v                   v
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // The first 'a is covariant, but the second one is invariant since it is
</span><span class="boring">    // &quot;inside&quot; a &amp;mut reference! This means that 'a is invariant, and this
</span><span class="boring">    // ends up causing the compiler to try and hold on to the list for longer
</span><span class="boring">    // than with the standard MessageCollector.
</span><span class="boring">}
</span></code></pre>
<p>Now the collector:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageDisplayer&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters:
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, the compiler can vary the two independently, so the list can be
</span><span class="boring">    // held onto a shorter lifetime than 'msg, then released.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots:
</span><span class="boring">    //
</span><span class="boring">    //     |               |
</span><span class="boring">    //     v               v
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // But since both of them are covariant (in immutable positions), 'a is
</span><span class="boring">    // covariant as well.  This means that the compiler can internally transform
</span><span class="boring">    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
</span><span class="boring">    // list for the shorter 'a duration.
</span><span class="boring">}
</span><span class="boring">
</span>struct MessageCollector&lt;'a, 'msg&gt; {
    // Two lifetime parameters, again:
    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
    // Here, 'a is covariant, but 'msg is invariant since it is &quot;inside&quot;
    // a &amp;mut reference. The compiler can vary the two independently, which
    // means that the list can be held onto for a shorter lifetime than 'msg.
}
<span class="boring">
</span><span class="boring">struct SimpleMessageCollector&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots again:
</span><span class="boring">    //
</span><span class="boring">    //     |                   |
</span><span class="boring">    //     v                   v
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // The first 'a is covariant, but the second one is invariant since it is
</span><span class="boring">    // &quot;inside&quot; a &amp;mut reference! This means that 'a is invariant, and this
</span><span class="boring">    // ends up causing the compiler to try and hold on to the list for longer
</span><span class="boring">    // than with the standard MessageCollector.
</span><span class="boring">}
</span></code></pre>
<p>Finally, the problematic simple version:</p>
<pre><code class="language-rust norun noplayground"><span class="boring">#![allow(dead_code)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Message&lt;'msg&gt; {
</span><span class="boring">    message: &amp;'msg str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageDisplayer&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters:
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, the compiler can vary the two independently, so the list can be
</span><span class="boring">    // held onto a shorter lifetime than 'msg, then released.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct SimpleMessageDisplayer&lt;'a&gt; {
</span><span class="boring">    // 'a is used in two spots:
</span><span class="boring">    //
</span><span class="boring">    //     |               |
</span><span class="boring">    //     v               v
</span><span class="boring">    list: &amp;'a Vec&lt;Message&lt;'a&gt;&gt;,
</span><span class="boring">    //
</span><span class="boring">    // But since both of them are covariant (in immutable positions), 'a is
</span><span class="boring">    // covariant as well.  This means that the compiler can internally transform
</span><span class="boring">    // &amp;'a Vec&lt;Message&lt;'msg&gt;&gt; into the shorter &amp;'a Vec&lt;Message&lt;'a&gt;&gt;, and hold the
</span><span class="boring">    // list for the shorter 'a duration.
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MessageCollector&lt;'a, 'msg&gt; {
</span><span class="boring">    // Two lifetime parameters, again:
</span><span class="boring">    list: &amp;'a mut Vec&lt;Message&lt;'msg&gt;&gt;,
</span><span class="boring">    // Here, 'a is covariant, but 'msg is invariant since it is &quot;inside&quot;
</span><span class="boring">    // a &amp;mut reference. The compiler can vary the two independently, which
</span><span class="boring">    // means that the list can be held onto for a shorter lifetime than 'msg.
</span><span class="boring">}
</span><span class="boring">
</span>struct SimpleMessageCollector&lt;'a&gt; {
    // 'a is used in two spots again:
    //
    //     |                   |
    //     v                   v
    list: &amp;'a mut Vec&lt;Message&lt;'a&gt;&gt;,
    //
    // The first 'a is covariant, but the second one is invariant since it is
    // &quot;inside&quot; a &amp;mut reference! This means that 'a is invariant, and this
    // ends up causing the compiler to try and hold on to the list for longer
    // than with the standard MessageCollector.
}
</code></pre>
<h3 id="a-final-note-if-youre-writing-a-rust-library"><a class="header" href="#a-final-note-if-youre-writing-a-rust-library">A final note if you're writing a Rust library</a></h3>
<p>Changing the variance of a parameter (lifetime or type) from <em>covariant</em> to
anything else, or from <em>contravariant</em> to anything else, is a BREAKING CHANGE.
If you're following semver, it can only be done with a new major version.</p>
<p>Changing a parameter from <em>invariant</em> to <em>co-</em> or <em>contravariant</em> is not a breaking change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h1>
<p>Hope this made you feel more confident using lifetimes in your Rust code!
They're a very powerful way to write safe, blazing fast code. But variance can
often cause obscure issues in practice -- knowledge of how it works is key to
using lifetimes effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<p>Thanks to the following people for their feedback:</p>
<ul>
<li>Nikolai Vazquez (<a href="https://twitter.com/NikolaiVazquez">Twitter</a>, <a href="https://github.com/nvzqz">GitHub</a>)</li>
<li>Inanna Malick (<a href="https://twitter.com/inanna_malick">Twitter</a>, <a href="https://github.com/inanna-malick">GitHub</a>)</li>
</ul>
<p>And thanks to Berkay Dinç (<a href="https://github.com/brkydnc">GitHub</a>) for converting the tutorial over to mdbook.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="additional/ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
